#### Проблемы с proftpd

Ниже будут изложены все проблемы, с которыми пришлось столкнутся 
при фазинге отдельной функции `pr_netio_raw_buffer_read()` из файла `src/netio.c` в проекте `proftpd`.

###### Что сказал автор-преподаватель

- На лекции был продемонстрирован пример с фазингом отдельной функции.
Пример был на `dotnet` (C#), в нем исследуемая функция выделялась в отдельную программу,
и был использован специальный фреймворк для фазинга. Из этого можно сделать вывод (и сам лектор это говорил),
что отдельные функции тестируются выделением их в отдельные программы. Таким же образом поступим и с 
нашей исследуемой сейчас функцией.
- Лектор сказал, что _"будет хорошо"_, если кто то сделает фазинг отдельной функции.
Это можно трактовать как "необязательная" часть задания,  и если сделать один фазинг `wisdom-alt`,
то уже будет сдано.

###### С чем столнулся, что делал и пробовал

- Выделить в отдельную функцию с отдельным `main()` не получится, поскольку в исследуемой
функции используется зависимость от `conf.h` (а в нем зависимость от `config.h`) из-за чего
весь проект нужно собирать целиком, чтобы собрать все зависимости вместе, с помощью `./configure`, `make` 
и `make install`, а значит нужно модифицировать `main()` в самом `proftpd` в файле `src/main.c`, а не выделять в отдельные файлики
- У меня не получилось собрать код, который лежит в папке `/code/proftpd`, из-за того, что 
не может найти зависимоти `supp` и `cup`. Интересно что версия скаченная с интернетов с помощью
`wget ftp://ftp.proftpd.org/distrib/source/proftpd-1.3.5b.tar.gz` собирается без проблем с **этими же
зависимостями**. Но в этой скаченной версии с `wget` в `src/netio.c` просто нет функции `pr_netio_raw_buffer_read()`. 
Почему - неизвестно. Поэтому единственныый вариант собрать проект с исследуемой функцией это заменить 
`src/netio.c` в скаченном проекте с `wget` кодом из "правильной" версии из `/code/proftpd`. Получившийся франкенштейн
получится скомпилировать и запустить.
- После того как собрали проект с исследуемой функцией можно приступать к модификации `main()`. Но - к сожалению - просто
очистить `main()` и вызвать свою функцию не получится. В качестве первого аргумента исследуемая функция принимает специальную
структуру входящего потока под названием `pr_netio_stream_t`, который описывается множеством параметров. Просто взять и создать
объект этой структуры не получится, нужно пользоватся готовым, который создается при запуске приложения. Такой объект находится в
структуре `session_t` в файле `main.c`. Где инициализируется этот объект - не найдешь. Получается что для запуска функции нужно
откуда то взять `pr_netio_stream_t`, инициализация которого неявна "как" и неизвестно "где". 
- Если захочется воспользоватся инициализированным `pr_netio_stream_t`, то придется не переписывать `main()`, а где то добавить одну
строку с вызывом исследуемой функции прям посреди процесса запуска программы. Задача сводится к вопроса: а куда это строку вставить? Она должна быть после инициализации `session_t`,
но перед циклом всей программы (программа в цикле ожидает подключение к себе по ftp). В силу запутанности проекта найти это место очень сложно.
Его можно найти только методом проб и ошибок, а мест где можно воткнутся - бесконечно много.
- Сама исследуемая функция вызывает другую функцию, а эта другая функция вызывает другую функцию - и так до бесконечности. Учесть 
их всех в запуске фазинге не получится: там вызывается шедулер, демоны, куча-куча всего. Исследуемая функция тригерит очень много последовательных
модулей и точно где-то что-то отвалится, если будем модифицировать код проекта отдельно от всего. Иными словами, мы пытаемся выдернуть одно звено 
большой цепи и пытаемся его запустить, и мы не знаем что было до этого звена, не знаем что происходит после этого звена, и пытаемся запустить это звено 
в вакууме как будто больше ничего нет. В таких больших системах это практически невозможно.

###### Какие проблемы мы имеем - тезисно

- Проект собран как франкенштейн двух версий неизвестного происхождения, и не известно как оно поведет себя в работе
- Функция требует специальных объектов, которые неизвестно откуда появляются, а просто использоват "затычку" для них не получится
- Функция участвует в очень длинном процессе цепочки вызовов с кучей побочных эффектов. Отдельный вызов функции - очень сложный и нестабильный процесс
- Функция требует особого состояния процесса, и получается надо врезатся где-то и как-то посреди процесса. Найти это "где-то" и "как-то" очень сложно, и сложнее,
чем сама лабараторная целиком. 

###### As result

В совокупности проблем выше, сил на запуск фазинга будет затрачено больше, чем сам процесс фазинга. Тратить силы на это не хочется.
Если кто то хочет убить силы и время на запуск этого всего, то выше описано всё что надо сделать. 